---
title: 그리디 알고리즘의 정당성 증명
categories: Algorithm
date: 2022-03-09
tags:
    - algorithm
    - greedy algorithm
---

**Note:** 본 글은 이전에 작성한 글을 백업한 것입니다.
{: .notice--info}


**Greedy Algorithm**은 (전체가 아닌) 부분에서 최적의 해를 구하는 것이 전체 문제의 최적 해가 될때 사용하는 알고리즘으로, 정당성을 증명해야 답을 보장할 수 있다. 다음의 문제들에서 그리디 알고리즘을 사용해 정당성 증명을 연습할 수 있다.

### <문제> 거스름 돈

`n`원을 `10원`, `50원`, `100원`, `500원` 동전으로 거슬러 주려고 할 때, 거슬러주는 동전의 개수를 최소화하려고 한다. 이때 거슬러 주는 동전의 최소 개수를 반환하는 문제이다.

#### 문제 해결 아이디어

- 전략: 가장 큰 화폐 단위부터 거슬러 준다.
- 정당성 증명: 거슬러 줄 동전 중 큰 단위가 항상 작은 단위의 배수이므로, 같은 돈을 거슬러 주는 방법 중 가장 적은 동전을 사용하는 방법은 가능한 한 가장 큰 단위의 동전을 사용하는 것이다.
- 즉 동전의 단위가 500원, 400원, 100원으로 주어진 경우에는 그리디 알고리즘으로 해답을 구할 수 없다.

#### 파이썬 코드

```python
coins = [500, 100, 50, 10]
cnt = 0

for coin in coins:
	cnt += n // coin
	n %= coin

print(count) 
```



### <문제> 1이 될 때까지

1이 아닌 숫자 `N`과 `K`가 주어진다. 오직 두 가지 연산만 할 수 있는데, N이 K로 나누어지는 경우 `N을 K로 나눌` 수 있고, 그 외의 경우에는 `N에서 1을 뺄` 수 있다. 여기서 N을 1로 만드는 최소 연산 횟수를 구하는 문제다.

#### 문제 해결 아이디어

- 전략 : 숫자 N이 K로 나누어지는 경우의 수를 최대한으로 하되, 만약 N이 K로 나누어지지 않으면 1을 뺀다.
- 정당성 증명: 만약 N이 K로 나누어지면, N과 K는 1이 아니므로 N 나누기 K 는 N - 1보다 작은 값이 된다. 언제나 1을 빼는 것으로 N을 1로 만들 수 있으므로, 매번 N을 최대한 작은 수로 만드는 방법으로 전체 연산 횟수를 최소화 할 수 있다.

#### 파이썬 코드

```python
n, k = map(int, input().split())
cnt = 0

while n >= k:
	if n % k == 0:
		cnt += 1
		n //= k
	else:
		cnt += n % k
		n -= n % k

print(cnt + n - 1)
```


### <문제> 곱하기 혹은 더하기

0 또는 양수인 임의의 수들 `s`가 주어질 때, 두 수를 더하거나 곱해서 만들 수 있는 가장 큰 수를 반환하는 문제다.

#### 문제 해결 아이디어

- 전략 : 피연산자 두개 중 하나라도 0이나 1이면 더하고, 그 외의 경우면 곱한다.
- 정당성 증명: 연산의 왼쪽 숫자를 임의의 수 N이라 할 때, 모든 수는 0 또는 양수이므로 `N * 0 = 0` 보다 `N + 0 = N` 이 같거나 크고, `N * 1 = N` 보다 `N + 1` 이 더 크다. 반면, 2이상 9이하의 정수 X에 대해 `N * X` 보다 `N + X` 가 같거나 작다. 곱셈과 덧셈은 교환법칙이 성립하므로 피연산자의 순서에 관계없이 법칙이 성립한다.

#### 파이썬 코드

```python
s = input()
ret = int(s[0])

for i in range(1, len(s)):
	num = int(s[i])
	if num <= 1 or ret <= 1: 
		ret += num
	else:
		ret *= num

print(ret)
```


### <문제> 모험가 길드

어떤 마을에 모험가들이 있다. 모험가들은 제각기 공포도가 있는데, 공포도가 `i`인 사람은 `i`명 이상이 속한 그룹에 들어야 모험을 나갈 수 있다. 모험가들의 공포도가 주어질 때, 모험을 나가는 그룹의 수를 최대화해서 반환하는 문제다. 단, 모험가들이 마을에 남아있는 경우도 허용된다.

#### 문제 해결 아이디어

- 전략: 공포도가 적은 사람부터 순서대로 그룹을 꾸리되, 그룹의 최소 정원이 만족되면 다음 그룹으로 편성한다.
- 정당성 증명: 주어진 정보에 대해 그룹수가 최대가 되도록 꾸려진 임의의 편성이 있다고 하자. 이 편성의 한 그룹에 대해 공포도가 적은 사람부터 그룹의 최소 정원을 만족하도록 그룹을 만들고 이외의 모험가들을 제외시켜도 여전히 그룹의 수는 최대이다. 따라서 위의 전략은 최적의 해를 보장한다.

#### 파이썬 코드

```python
n = int(input())
fears = list(map(int, input().split()))
fears.sort()

# cnt : 각 그룹에 포함된 사람의 수
# ret : 전체 그룹의 수
cnt, ret = 0, 0

for fear in fears:
	cnt += 1
	# fear가 cnt를 넘으면,
	# 전체 그룹 수를 1 증가하고 cnt를 초기화 한다. 
	if cnt >= fear:
		ret += 1
		cnt = 0
	
print(ret)
```

### 참고자료

- 문제 출처 : [이코테 유튜브](https://www.youtube.com/watch?v=m-9pAwq1o3w&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=1)
- Coursera, Algorithmic Toolbox, Greedy Algorithm
