{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"85756ac4-947a-5dc4-a005-a9c53b94d8fd","excerpt":"Hugging Face의 CompVis/stable-diffusion-v1-4(Click!) 모델 API를 이용하여 프롬프트에 대한 이미지를 생성해보았다. 특히, Apple Silicon(arm64, M1) 환경에서 위 코드를 실행하며 마주쳤던 에러와 한계점에 대해 기록하고자 한다. macOS Monterey 12.5.1 Apple M1 Python 3.10.10 위의 코드는 float32 대신 float16 타입으로 모델을 로딩하도록 하며, 로딩한 파이프라인을 CUDA를 사용해 연산하고자 한다. 그러나 CUDA는 NVIDIA G…","frontmatter":{"title":"[DL] Apple M1에서 HuggingFace API 활용하기","subtitle":"ft. Stable Diffusion","draft":false,"date":"June 07, 2023"},"fields":{"slug":"/AI/DL/stable-diffusion-pipe/"}}},{"node":{"id":"6427a274-d7e6-5453-a57c-ae036fb64901","excerpt":"VS code에서 머신러닝 모델을 탑재한 웹 서비스를 Fast API로 서빙하기 위한 환경을 세팅해본다. VS code 확장인 Pylance를 이용하기 위해 3.10 이상의 Python 가상환경을 설치한다. Pylance를 설치하기 위해서는 Python 3.10.0 이상의 버전이 필요하다. 여기서는 VS code에서 Python 3.10.x 버전의 가상환경을 설정한다. Homebrew의 파이썬 버전 관리 라이브러리 pyenv를 설치하고 원하는 파이썬 버전을 설치한다. 설치한 파이썬 버전을 전역 파이썬 환경으로 설정한다. VS co…","frontmatter":{"title":"[DL] Apple M1에서 VS code 환경 세팅하기","subtitle":"","draft":false,"date":"June 06, 2023"},"fields":{"slug":"/AI/DL/vscode-setting/"}}},{"node":{"id":"38af05ae-3dfa-5d3e-9391-b8d5c21a030f","excerpt":"1. 최적화 최적화는 컴퓨터 공학의 중요한 주제이다. 최적화가 필요한 문제는 대체로 문제 해결을 위한 사전 정보가 부족하거나 일괄적인 법칙으로 해결할 수가 없다. 다시말해 최적화는 탐색과 문제 해결을 동시에 진행할 수 있는 방법이며, 사전 정보가 크게 필요하지 않다. 최적화는 크게 조합 최적화와 연속적 최적화로 나눌 수 있는데, 여기서는 신경망이 활용하는 Gradient Descent라는 연속적 최적화 방식에 대해 다루고자 한다. 1.1 Gradient Descent Gradient Descent(GD)란 미분가능한 함수의 국소적…","frontmatter":{"title":"[DL] Gradient Descent 최적화","subtitle":"SGD, BGD, Learning Rate Decay, Momentum","draft":false,"date":"June 05, 2023"},"fields":{"slug":"/AI/DL/optimization-1/"}}},{"node":{"id":"e909ee39-a00a-543a-b360-738ae7c60447","excerpt":"깃허브 이슈로 댓글을 관리하는 utterances 🔮 utterances는 댓글을 깃허브 이슈로 관리하는 위젯이다. utterances를 깃허브 르포에 설치하면 utterances-bot이 모든 페이지를 방문하여 댓글이 있는 페이지마다 이슈를 생성한 뒤 댓글을 그 이슈에 추가한다. 즉 utterances 댓글을 다는 행위는 이슈를 추가하거나 이슈 내에 글을 추가하는 것과 같으므로, 댓글 작성에 깃허브 계정이 필요하다. 1. utterances app 을 댓글을 관리할 르포에 설치한다. 이때 르포는 public이어야 한다. 이 블로…","frontmatter":{"title":"[Gatsby] utterances 추가하기","subtitle":"React에 컴포넌트를 추가하는 방법","draft":false,"date":"May 31, 2023"},"fields":{"slug":"/CS/Web/utterances/"}}},{"node":{"id":"7abfdf0e-de50-556e-8f4e-e0eb4673fa84","excerpt":"요약 원칙 1: 명확하고 구체적인 지시 사항을 전달한다. Tactic 1: 구획 문자(delimiters)를 사용하여 입력의 부분들을 분명하게 구분한다. Tactic 2: 구조화된 아웃풋을 요구한다. Tactic 3: 모델에게 결과 도출 조건들이 충족되었는지 확인하도록 지시한다. Tactic 4: \"Few-shot\" 프롬프트를 제공한다. 원칙 2: 모델이 \"생각\"할 시간을 준다. Tactic 1: 과제를 완료하기 위한 단계를 구체화한다. Tactic 2: 모델이 결과를 도출하기 전에, 먼저 스스로 답을 생성하고 이를 결과와 비교해…","frontmatter":{"title":"ChatGPT 프롬프트 엔지니어링 가이드라인","subtitle":"[Lecture] ChatGPT Prompt Engineering for Developers","draft":false,"date":"May 27, 2023"},"fields":{"slug":"/AI/Text/chatgpt-prompt-engineering/"}}},{"node":{"id":"7f2ea952-e56c-53e3-9885-79d2f7ef8545","excerpt":"AI 기사 브리핑 웹 서비스 0. 기간 : 2023.05 ~ 진행중 1. 주요 기능 : MVP Node.js 환경 구현 JavaScript 1분 마다 네이버 뉴스의 분야별 주요 뉴스 스크레이핑 ainaize/kobart-news HuggingFace API를 통해 뉴스 기사 요약 (RESTful API) parcel 번들링 Netlify 배포 Advance Dockerization Fine-Tuning 또는 Prompting을 통한 결과 제어 (nomic-ai/gpt4all-j) 음성 생성을 통한 읽어주기 서비스 (microsof…","frontmatter":{"title":"[Ongoing] briefing-now","subtitle":"💡 AI 기사 브리핑 웹 서비스","draft":false,"date":"May 22, 2023"},"fields":{"slug":"/+ Project/briefing-now/"}}},{"node":{"id":"c05fef09-c47d-5cad-ab2e-1e91ecf9714f","excerpt":"gatsby-remark-katex를 설치했다. 먼저, gatsby-remark-katex와 katex를 npm으로 다운받는다. 이제 gatsby-config.js 파일에 플러그인을 추가한다. 마지막으로 /src/templates/blog-post.js에 다음 코드를 추가한다. 이 경로는 Gatsby 폴더 구조에 따라 조금 다를 것이다. Gatsby의 플러그인 설치는 간단한 것이 장점이라고 느꼈다.","frontmatter":{"title":"[Gatsby] Gatsby Plugin Katex 설치","subtitle":"gatsby-remark-katex","draft":false,"date":"May 21, 2023"},"fields":{"slug":"/CS/Web/gatsby-plugin-katex/"}}},{"node":{"id":"01d95e23-c855-5b3a-ab8b-4d6ba7bb26df","excerpt":"요약 : javascript string을 두번 디코딩하지 말자. 다음과 같은 warning이 발생하며 디코딩이 작동하지 않는다. 상황은 axios와 iconv로 스크레이핑을 하는 다음 코드에서 발생했다. response 버퍼에 저장된 값을 불러와 EUC-KR로 디코딩을 시도했다. Node.js v18.16.0 원인은 이중 디코딩 로그에서 주어진 링크로 들어가면 deprecation 원인이 설명되어 있다. 이미 저장된 string을 불러와 디코딩하는 경우, 처음 string 저장을 할 때 이미 JavaScript에서 utf-8으로…","frontmatter":{"title":"[JS] decode()-ing 및 Buffer() deprecation","subtitle":"Iconv-lite warning: decode()-ing strings is deprecated.","draft":false,"date":"May 21, 2023"},"fields":{"slug":"/CS/Web/js-buffer-deprecation/"}}},{"node":{"id":"9c6ae02a-2711-582c-bd03-c4ec803ea17c","excerpt":"0. Ground : Gatsby-Clean-Blog-Starter 👏🏼 Quick Start /  More 1. Additional PlugIns  gatsby-remark-katex (latex parsing)  gatsby-remark-vscode (syntax highlighting)  gatsby-plugin-sitemap  gatsby-remark-images-custom-widths  gatsby-remark-embedder Google 등 검색 노출 (SEO) 포스트 단위 검색 글 박스 만들기 북마크 템플릿 만들기 2…","frontmatter":{"title":"[Ongoing] Gatsby 블로그 개발","subtitle":"💡 This site!","draft":false,"date":"May 21, 2023"},"fields":{"slug":"/+ Project/gatsby-blog/"}}},{"node":{"id":"8e193e39-7058-5e1d-981e-e730ae7a0450","excerpt":"지식 증류(Knowledge Distillation)는 학습된 크기가 큰 모델(들)의 정보를 최대한 보존하면서 크기는 작은 모델로 옮기는 방법을 다루고 있다. 따라서 모델 학습을 마친 후 배포하는 과정 등 연산 제약이 있는 경우 고려해 볼 수 있는 기술이다. Paper : Distilling the Knowledge in a Neural Network 1. 지식 증류 1.1 개요 지식 증류는 분류를 수행하는 큰(cumbersome) 뉴럴 네트워크가 학습한 soft target을 활용해 규모가 작은(small) 모델에 효과적으로 t…","frontmatter":{"title":"[Paper] Knowledge Distillation, 2015","subtitle":"soft target을 활용한 모델 가속화 방법","draft":false,"date":"March 14, 2023"},"fields":{"slug":"/AI/DL/2023-03-14-knowledge-distillation/"}}},{"node":{"id":"15455dcc-bf8a-53d3-8c9e-d20082901c09","excerpt":"비디오 트랜스포머인 ViViT의 토큰화 방법 두가지를 구현하고 비교해보자. 비디오 같은 3D 비전 데이터셋은 2D 이미지 데이터셋과 유사하지만 시간 차원을 하나 더 가지고 있다. 이미지 데이터를 트랜스포머로 다루는 ViT에서 토큰화 방법이 중요했던 만큼, ViViT에서도 토큰화 방법이 중요한 영향을 끼치지 않을까하는 질문에서 시작해 논문 ViViT: A Video Vision Transformer에 소개된 두가지 토큰화 방법을 비교해보기로 했다. 실험은 각각의 토큰화 방법을 활용한 모델을 같은 데이터셋과 하이퍼파라미터로 학습을 했…","frontmatter":{"title":"[실험] ViViT의 토큰화 방법 비교하기","subtitle":"","draft":false,"date":"February 21, 2023"},"fields":{"slug":"/AI/Vision/vivit-tokenizing/"}}},{"node":{"id":"10917a54-58aa-50ac-95e2-86445cbfa78a","excerpt":"원하는 정보가 여러 테이블에 흩어져 있는 경우, 몇 개의 외부 테이블을 합치는 명령어가 필요하다. Pandas 패키지에서 데이터프레임을 병합하는 경우를 생각해보자(사실 pandas 공식 문서에는 merge를 SQL의 JOIN을 들어 설명하고 있지만, 이미 pandas를 사용해본 경험이 있다면 이해가 빠를 것이다). df1.merge(df2, how='inner', on='col1')명령어는 df1에 df2를 양쪽 데이터프레임에 공통적으로 존재하는 col1의 값들이 일치되도록 병합한다. 반면 df1.merge(df2, how='le…","frontmatter":{"title":"[MySQL] JOIN","subtitle":"","draft":false,"date":"December 31, 2022"},"fields":{"slug":"/CS/DBMS/2022-12-31-dbms-mysql-join/"}}},{"node":{"id":"661b2a72-b614-562e-97e7-7fc0ae9db368","excerpt":"함수 문자열 함수 파이썬에는 정규표현식 개념이 있어서 패턴에 맞는 문자열을 검색할 수 있다. SQL에도 비슷한 기능이 있다. LIKE {...%패턴...} : %에 해당되는 문자가 없거나 여러개의 문자가 해당될 수 있다. LIKE {..._패턴...} : _에는 한 개의 문자만 대응 될 수 있다. REPLACE({문자열}, {대체될 문자열}, {대체할 문자열}) : 문자열에서 부분 문자열을 찾아 다른 문자열로 대체할 수 있다. 입력한 문자열을 순서대로 이어주는 파이썬의 join과 비슷한 기능을 하는 함수도 있다. CONCAT ({…","frontmatter":{"title":"[MySQL] 함수와 집계함수","subtitle":"","draft":false,"date":"December 31, 2022"},"fields":{"slug":"/CS/DBMS/2022-12-31-dbms-mysql-functions/"}}},{"node":{"id":"18f3de7d-3ab0-5c80-a13b-f4edfd79a48c","excerpt":"DDL (Data Definition Language) 테이블 자체를 추가/삭제/변형한다. CREATE TABLE CREATE TABLE {테이블 이름} ({칼럼1}{칼럼1 자료형}{칼럼1 옵션}, ..., {칼럼N}{칼럼N 자료형}{칼럼N 옵션}) : 테이블 생성 옵션은 생략할 수 있다. AUTO_INCREMENT는 행을 생성 할 때마다 자동으로 1씩 증가하는 칼럼 옵션이다. UNIQUE는 중복 입력만 불가한 칼럼 옵션이다. NOT NULL은 NULL 값만 입력 불가한 칼럼 옵션이다. PRIMARY KEY는 중복 입력과 NULL…","frontmatter":{"title":"[MySQL] DDL과 DML","subtitle":"","draft":false,"date":"December 31, 2022"},"fields":{"slug":"/CS/DBMS/2022-12-31-dbms-mysql-ddl-n-dml/"}}},{"node":{"id":"16ba0035-75e5-5b1f-a5ee-643a32a96221","excerpt":"여기서 웹으로 SQL 쿼리를 실행해 볼 수 있다. SQL 쿼리는 대문자와 소문자를 구분하지 않는다. 즉, 쿼리를 대문자로 쓰던 소문자로 쓰던 섞어서 쓰던 같은 결과를 도출한다. 아래에서 다루겠지만, 함수뿐만이 아닌 문자열 데이터도 대문자와 소문자를 구분하지 않는다. SQL 쿼리의 한 줄 주석은 -- {주석} 형태로 쓴다. 기본 사용법 데이터베이스에서 테이블의 행을 검색하기 위한 가장 기본적인 함수는 SELECT {칼럼(column)의 이름, 또는 불러올 값}이며 칼럼을 검색하는 경우 뒤에 FROM {테이블}로 칼럼이 속한 테이블 …","frontmatter":{"title":"[MySQL] Basics","subtitle":"","draft":false,"date":"December 31, 2022"},"fields":{"slug":"/CS/DBMS/2022-12-31-dbms-mysql-basics/"}}},{"node":{"id":"b6e617e8-c762-5e55-9322-819535e67067","excerpt":"파일 처리 예시를 통해 알아보자. 다음 코드는 파일을 읽어들이고 빈줄을 제거해 저장한다. 파일 처리 메서드 open(), close() open(filename, mode, encoding) 메서드는 파일 객체를 반환한다.\nclose()는 파일 객체를 닫으며 try .. except .. finally 구문으로 다음과 같이 사용할 수 있다. 또는 처음의 예시처럼 with open(...) as f_object로 close()를 명시하지 않고 같은 기능을 구현할 수 있다.\nclose()는 열린 파일이 차지하는 시스템 자원을 해제(f…","frontmatter":{"title":"[Python] 파일 처리 - shutil, pickle, struct","subtitle":"python에서 파일 처리 방법과 관련 모듈에 대해","draft":false,"date":"November 10, 2022"},"fields":{"slug":"/CS/Python/2022-11-10-python-file/"}}},{"node":{"id":"777ea8d2-af4b-5e08-bcfc-8b429b210c06","excerpt":"원 논문 : Flow-Guided Feature Aggregation for Video Object Detection, 2017 들어가며 시퀀스 데이터에 관심을 가지다 보니, 최근에는 시퀀셜한 이미지인 비디오 데이터(sequence of related frames)에 관심을 가지게 되었다. 물론 프레임 별로 이미지 과제를 수행하면 수행 시간이나 정확도 측면에서 비효율적일 것이라는 생각이 들었다. 그러므로 현재는 어떤 식으로 비디오 처리 과제를 수행하고 있는지 관련 발표 자료를 찾아보게 되었다. 실제로 현실에서 대부분의 사물은 움직…","frontmatter":{"title":"[Paper] FGFA for Video Object Detection, 2017","subtitle":"비디오 개체 인식 모델","draft":false,"date":"November 08, 2022"},"fields":{"slug":"/AI/Vision/fgfa/"}}},{"node":{"id":"a5a975cf-3813-5514-a755-de2c9e630c9f","excerpt":"딕셔너리 Python의 dict(딕셔너리)는 해시 테이블로 구현되어 있다. 따라서 딕셔너리의 고유한 키에 해당하는 값을 상수 시간 내에 얻을 수 있다. 딕셔너리는 가변 객체이므로 항목의 추가 및 제거가 가능하지만, 인덱스 위치를 사용하여 접근하는 것은 불가능하며 삽입 순서를 기억하지 않는다. 컬렉션 매핑 타입(mapping type)인 딕셔너리는 iterable 객체로, 멤버십 연산자 in과 len() 함수를 지원한다. 매핑은 key-value 항목의 컬렉션으로 각 항목에 대해 메서드를 제공한다. 딕셔너리 메서드 setdefaul…","frontmatter":{"title":"[Python] 컬렉션 자료구조 - dict","subtitle":"","draft":false,"date":"November 03, 2022"},"fields":{"slug":"/CS/Python/2022-11-03-python-dictionary/"}}},{"node":{"id":"4866c30f-846f-5af5-acd5-186460dd2446","excerpt":"셋 Python의 set(셋)은 수학의 집합 개념에 기반한 컬렉션 데이터 타입으로, 중복 요소가 없고 정렬되지 않은\n컨테이너(container)이다. 셋에는 순서의 개념이 없으므로 인덱스 연산은 불가능하며 주로 멤버십 테스트 및 중복 항목 제거를 위해\n사용된다. 셋에서 항목을 삽입하는 시간 복잡도는 이고, 두개 집합의 합집합(union)의 경우 시간 복잡도는 각 집합의 원소\n개수 m과 n에 대해 이다. 교집합(intersection)의 경우 일때 이다. 셋 메서드 add() A.add(x)는 셋 A에 항목 x를 추가한다. 이미 항…","frontmatter":{"title":"[Python] 컬렉션 자료구조 - set","subtitle":"","draft":false,"date":"November 03, 2022"},"fields":{"slug":"/CS/Python/2022-11-03-python-set/"}}},{"node":{"id":"8f453aae-945b-5368-bbf3-639203e720a0","excerpt":"Python의 내장 시퀀스 데이터 타입인 리스트에 대해 알아본다. 리스트 파이썬 리스트는 동적 배열(array)로, 연결 리스트(linked list)와는 관련이 없다. 리스트는 항목을 쉼표 ,로 구분하고, 대괄호 []로 감싼다. 리스트의 항목은 서로 다른 데이터 타입일 수 있으며, 인덱스로 특정 요소에 접근하여 항목 값을 변경할 수 있다(가변 타입). 리스트 메서드 append() A.append(x)는 리스트 A의 오른쪽에 항목 x를 추가한다. 시간복잡도는 이다. A[len(A):] = [x]로\n같은 기능을 구현할 수 있다. …","frontmatter":{"title":"[Python] 시퀀스 자료구조 - list","subtitle":"","draft":false,"date":"November 01, 2022"},"fields":{"slug":"/CS/Python/2022-11-01-python-list/"}}},{"node":{"id":"47b8229f-b16a-5169-8f57-41a01c06cb99","excerpt":"문자열(string)은 문자(character)의 시퀀스이다. 파이썬은 불변의 str 타입을 통해 문자열을 표현한다. 파이썬의 객체는 두가지 출력 형식이 있는데, 문자열 형식은 형식은 사람이 읽기 위한 형태이고, representation 형식은 파이썬 인터프리터가 읽기 위해 사용되는 형식으로 디버깅에 사용된다. 유니코드 문자열 유니코드(Unicode)란 아스키 문자를 기반으로 지구의 모든 문자를 표현하는 목적으로 정의된 국제 표준 코드이다. 유니코드에는 공백,\n특수문자, 수학 기호 등을 포함하고 있다. Python은 3부터 모든…","frontmatter":{"title":"[Python] 시퀀스 자료구조 - str","subtitle":"& Unicode(UTF-8)","draft":false,"date":"October 31, 2022"},"fields":{"slug":"/CS/Python/2022-10-31-python-string/"}}},{"node":{"id":"dd625fd1-f021-59d1-8dfa-ecae0b10e044","excerpt":"튜플 튜플tuple은 쉼표 ,로 구분된 값으로 이루어진 불변 시퀀스 타입이다. 문자열과 같이 튜플은 인덱스를 통한 객체 참조가 가능하다. 쉼표 ,는 튜플을 만들지만 괄호 ()만으로는 튜플을 만들 수 없다. 튜플은 리스트 같은 가변 객체를 값으로 포함할 수 있다. 튜플 메서드 A.count(x)는 튜플 A에 담긴 값 x의 개수를 반환하며, A.index(x)는 x의 인덱스를 반환한다. 튜플 언패킹 파이썬의 모든 iterable 객체는 시퀀스 언패킹 연산자(sequence unpacking operator) *를 통해 언패킹할\n수 있…","frontmatter":{"title":"[Python] 시퀀스 자료구조 - tuple","subtitle":"","draft":false,"date":"October 31, 2022"},"fields":{"slug":"/CS/Python/2022-10-31-python-tuple/"}}},{"node":{"id":"ddabb3d0-e62e-575e-9029-2b69fb586efd","excerpt":"한국어 토큰화(또는 형태소 분석)를 파이썬 패키지 KoNLPy를 이용하여 수행해보자. 0. 왜 필요한가? 한국어는 토크나이징이 어려운 언어이다. 한국어는 영어와 달리 명사와 조사를 띄어쓰지 않는다. 한국어는 어순이 아니라 조사 또는 조사의 유무에 따라 문법적 기능이 정해진다. 한국어는 띄어쓰기 규칙이 모호하다. 한국어는 주어를 생략할 수 있고, 평서문과 의문문에 문법적 차이가 없다. ex. '집에 갔어.', '집에 갔어?' 따라서 최소의 의미 단위인 형태소를 분석하는 도구(Morphological Analyzer)가 필요하다. 형…","frontmatter":{"title":"[KR] KoNLPy로 한국어 토큰화하기","subtitle":"한국어 처리 통합 패키지 KoNLPy를 알아보자.","draft":false,"date":"September 27, 2022"},"fields":{"slug":"/AI/Text/konlpy/"}}},{"node":{"id":"1796ef82-f4ce-5991-ae8b-1eeab00fb4ee","excerpt":"Demand paging 시스템의 안정성을 방해하는 페이지 대체(Page Replacement)와 프레임 할당(Frame allocation) 문제와 대처 전략들을 알아본다. 0. Demand paging Demand paging은 프로세스를 메모리에 적재할 때 실행에 요구되는 페이지만 적재하는 기법이다. CPU가 페이지에 접근하는 명령어를 실행하면, 해당 페이지가 메모리에 있는 경우 (valid bit = 1), CPU는 해당 메모리가 적재된 프레임에 접근한다. 해당 페이지가 메모리에 없는 경우 (valid bit = 0), P…","frontmatter":{"title":"[OS] 페이지 대체와 프레임 할당","subtitle":"","draft":false,"date":"September 06, 2022"},"fields":{"slug":"/CS/OS/2022-09-06-cs-virtual-memory-2/"}}},{"node":{"id":"37881833-3567-59bb-8716-ca18eab568d6","excerpt":"0. Contiguous Allocation 연속 메모리 할당은 프로세스를 연속적으로 메모리 공간에 할당하는 방식이다. 0.1. Swapping 스와핑이란 메모리에 적재되어 있지만 실행되지 않은 프로세스를 보조기억 장치로 옮기고 메모리에 다른 프로세스를 적재하여 실행하는 방식이다. 스와핑을 통해 여러 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 물리 메모리 크기보다 큰 경우에도 동시에 실행할 수 있다. swap out 되었던 프로세스가 swap in 될때는 이전과 다른 주소에 적재될 수 있다.  Swap space. $ …","frontmatter":{"title":"[OS] 가상 메모리(Virtual Memory)와 페이징(Paging)","subtitle":"","draft":false,"date":"September 06, 2022"},"fields":{"slug":"/CS/OS/2022-09-06-cs-virtual-memory-1/"}}},{"node":{"id":"f22fc425-7d58-5bad-a051-2d6a8e8b060d","excerpt":"자원 할당 문제인 데드락에 대해 알아본다. Deadlock 표현과 조건 Dining philosopher's problem  Dining Philosopher, from https://www.cs.cornell.edu/courses/cs4410/2015su/lectures/lec10-deadlock.html 철학자는 자신의 왼쪽과 오른쪽에 있는 젓가락을 모두 들어야 식사를 할 수 있다. 젓가락을 한번에 한명만 사용할 수 있고(mutual exclusion), 다른 철학자가 들고 있는 젓가락을 뺏을 수 없으며(no preemptio…","frontmatter":{"title":"[OS] 데드락","subtitle":"","draft":false,"date":"September 04, 2022"},"fields":{"slug":"/CS/OS/2022-09-04-cs-deadlock/"}}},{"node":{"id":"b2f75e09-d3c7-5446-8699-30610557befb","excerpt":"CPU 작업 순서 결정 방식인 CPU 스케줄링에 대해 알아본다. CPU Scheduling CPU 스케줄링이란 각각의 프로세스가 CPU를 사용할 시간과 우선순위를 정하는 것이다. Process Priority OS는 PCB에 우선순위를 명시하고, 이를 기준으로 우선순위가 높은 프로세스를 더 빨리 실행할 수 있다. 실행 과제에 따라서 입출력 장치의 실행속도는 CPU 연산 속도보다 느리기 때문에, 대기 상태에 있는 시간이 실행 상태에 있는 시간보다 긴 I/O bound process를 먼저 실행할 수 있다. 반대로 CPU bound …","frontmatter":{"title":"[OS] CPU 스케줄링","subtitle":"","draft":false,"date":"September 03, 2022"},"fields":{"slug":"/CS/OS/2022-09-04-cs-cpu-scheduling/"}}},{"node":{"id":"f88bf9b8-1001-5519-a5ee-9c4dcd81d7d6","excerpt":"Process  사용자가 보는 곳에서 실행되는 프로세스는 foreground process, 사용자가 보지 못하는 곳에서 실행되는 프로세스는 background process라고 한다. background process 중 사용자와 상호작용하지 않는 프로세스를 daemon(유닉스 체계 OS) 또는 service(윈도우 OS)라고 부른다. PCB; Process Control Block OS의 PCB란 프로세스의 실행 순서와 자원 배분을 관리하는 자료 구조이다. PCB는 커널 영역에 생성되며, 프로세스를 실행하기 위해 필요한 정보를…","frontmatter":{"title":"[OS] 프로세스와 스레드","subtitle":"","draft":false,"date":"September 03, 2022"},"fields":{"slug":"/CS/OS/2022-09-03-cs-process-n-thread/"}}},{"node":{"id":"d9c94a2f-a353-5da6-862b-006e2ef5f9e7","excerpt":"OS OS란 시스템의 자원과 동작을 관리하는 소프트웨어이다. OS는 부팅시에 메모리의 커널 영역에 적재되어 실행된다. 메모리는 커널 영역(kernel space)과 사용자 영역(user space)로 나뉜다. 사용자 영역에는 실행할 프로그램(process)들이 적재된다. OS는 커널(kernel)과 UI를 제공한다. 커널은 OS의 핵심 서비스를 담당한다. UI; User Interface는 컴퓨터와 사용자가 상호작용 할 수 있게한다. GUI; Graphic User Interface는 그래픽 기반 인터페이스이고, CLI; Comm…","frontmatter":{"title":"[OS] 운영 체제","subtitle":"","draft":false,"date":"August 31, 2022"},"fields":{"slug":"/CS/OS/2022-08-31-cs-os/"}}},{"node":{"id":"274fbfa9-8360-5608-ac6d-43f1e4e8569f","excerpt":"1. 배시 쉘 명령어 (Bash shell commands) 디렉토리 .git 내 모든 파일 출력 숨겨진 파일을 포함해 현재 디렉토리에 위치한 모든 파일 출력 파일 file_name.py 생성하기 atom 에디터로 파일 file_name.py 열기 파일 file_name.py 내용 쉘에서 보기 2. 설정 명령어 (Configuration commands) 깃 현재 설정 출력하기 깃의 이름, 이메일 설정 변경하기 깃허브 키를 15분 동안 캐시하기 3. 스테이징 & 커밋 명령어 (Staging & Commit commands) 현재 …","frontmatter":{"title":"[Git] 깃 치트 시트","subtitle":"Cheat Sheet on Git","draft":false,"date":"August 30, 2022"},"fields":{"slug":"/CS/Git/git-cheat-sheet/"}}},{"node":{"id":"2ac2d0e5-9abf-5816-9ae8-48f325a57633","excerpt":"발단 르포를 작성해 깃허브로 푸시를 하던 도중, 깃허브 프로필에 등장하는 커밋 히스토리가 업데이트 되지 않는다는 것을 발견했다. 날짜에 따라 녹색으로 시각화되어서 \"잔디\"라고 부르는데, 원인을 탐색하다보니 커밋의 저자가 깃허브 계정과 다르게 설정되어 있다는 것을 알았다. 그래서 과거의 커밋들의 저자를 바꾸는 작업을 진행했다. 과정 git config 수정 우선 실행하기 전에, git의 config에서 user.name과 user.email 값이 제대로 설정되어 있는지 확인한다. 만약 config 값에 user.name 또는 use…","frontmatter":{"title":"[Git] git rebase로 잔디 회복하기","subtitle":"⛳️","draft":false,"date":"August 30, 2022"},"fields":{"slug":"/CS/Git/git-rebase/"}}},{"node":{"id":"24f89843-b5b6-59df-a2ab-bbb2c00f4629","excerpt":"Paper : Image Style Transfer Using Convolutional Neural Networks 깊은 합성곱 신경망을 이용해 이미지의 내용과 스타일을 분리하고 결합하는 방법을 소개한다. 1. 들어가며 스타일을 이미지에 렌더링하는 것은 이미지의 질감을 바꾸는 것으로 이해할 수 있다. Notation: texture transformation은 질감 변화로, deep image representation은 깊은 이미지 표현식으로, content representation은 내용 표현식으로, style represe…","frontmatter":{"title":"[Paper] Image Style Transfer, 2016","subtitle":"","draft":false,"date":"August 30, 2022"},"fields":{"slug":"/AI/Vision/image-style-transfer/"}}},{"node":{"id":"115481f0-1d33-5209-a069-488b3d046f27","excerpt":"명령어 사이클 CPU는 프로그램에서 전달받은 명령어를 하나씩 실행한다. 이 명령어들은 정형화된 흐름을 반복하며 실행되는데,\n이 흐름을 명령어 사이클(instruction cycle)이라고 한다. 즉 프로그램의 명령어들은 명령어 사이클이 반복되며 실행된다고 볼 수 있다.  Instruction cycle: the process a CPU executes a program. 가능한 경우 인출 사이클과 실행 사이클을 오가면서 순차적으로 프로그램을 실행하고, 인출 사이클에서 실행 사이클을 갈 수 없는 경우 (간접 사이클)와 실행 사이클에…","frontmatter":{"title":"[컴퓨터 구조] CPU 명령어 사이클","subtitle":"","draft":false,"date":"August 30, 2022"},"fields":{"slug":"/CS/OS/2022-08-30-cs-instruction-2/"}}},{"node":{"id":"a4f7bc1c-4640-51e7-b7d1-badb5a5566bc","excerpt":"1. 소스 코드를 명령어로 일반적으로 컴퓨터에 명령을 내리기 위해서 사람이 소스 코드를 작성하여 실행한다.\n그러나 컴퓨터는 사람이 작성하는 소스 코드를 직접 실행할 수 없으므로, 반드시 명령어로 변환하는 작업이 필요하다.\n명령어는 CPU 내부에서 명령어 레지스터를 통해 제어 장치에 전달되어 실행된다. 실제로는 고급 언어로 쓰여진 소스 코드가 저급 언어로 쓰여진 오브젝트 코드로 변환되며, 오브젝트 코드의 명령어가 링킹을 통해\n실행 코드로 변형되어 실행되는 과정을 거친다. 이때 고급 언어 (high-level programming l…","frontmatter":{"title":"[컴퓨터 구조] CPU 명령어(Instruction)","subtitle":"","draft":false,"date":"August 30, 2022"},"fields":{"slug":"/CS/OS/2022-08-30-cs-instruction-1/"}}},{"node":{"id":"5abe8d4b-62b3-5954-ae43-e486ce842d26","excerpt":"정보 단위 bit 컴퓨터가 연산하는 최소의 정보 단위는 비트이다. 비트는 0과 1의 값만 가지므로 비트 개수  개에 대해  개의 정보를 표현할 수 있다. 따라서 많은 정보를 표현하기 위해 비트의 단위는 점점 커져왔다. 단위 크기 증가 배수 1 byte 8 bit   1 kB 1,000 byte   1 MB 1,000 kB   1 GB 1,000 MB   1 TB 1,000 GB   워드(word)란 CPU가 한 번에 처리할 수 있는 데이터 크기를 의미한다. 현대의 CPU의 워드는 대부분 32 비트나 64 비트이다. 이진법(bina…","frontmatter":{"title":"[컴퓨터 구조] 데이터 타입","subtitle":"","draft":false,"date":"August 30, 2022"},"fields":{"slug":"/CS/OS/2022-08-30-cs-data/"}}},{"node":{"id":"2e8fa597-2b1a-50f4-b35a-19068dc905a8","excerpt":"1. Expanding clocks, cores, and threads 하드웨어 관점에서 CPU 성능을 높이는 방법을 알아본다. 1.1 클럭 (clock) 클럭 속도는 1초에 반복되는 주기의 수로 정의되는 헤르츠(Hz)로 측정한다. 이 글을 쓰고 있는 컴퓨터의 클럭 속도는 3.2GHz이므로, 1초에 클럭이 32억번 반복되는 셈이다. 클럭은 고정된 값이 아니며, CPU가 고성능을 요하는 순간에 클럭 속도를 높이고 그렇지 않을 때는 낮출 수 있다. 일정 범위 내에서는 클럭 속도를 높여 CPU 성능을 향상시킬 수 있다. 최대 클럭 속도…","frontmatter":{"title":"[컴퓨터 구조] CPU 성능 향상 방법","subtitle":"","draft":false,"date":"August 30, 2022"},"fields":{"slug":"/CS/OS/2022-08-30-cs-cpu-performance/"}}},{"node":{"id":"02ca59c7-7a10-55ec-b257-4e4b9a642211","excerpt":"웹 크롤링은 재귀적으로 페이지에서 URL을 찾아 다시 페이지를 불러오는 작업을 반복한다. 스크레이퍼는 모든 데이터가 페이지 하나에 들어 있는 경우에는 잘 동작하지만, 크롤러를 사용할 때는 대역폭에 주의를 기울여 타깃 서버의 부하를 줄일 방법을 강구해야 한다. 1. 단일 도메인 탐색하기 Wikipedia의 HTML 텍스트를 가져오는 프로그램을 작성해 보자. 위키백과 데이터를 사용하는 대규모 프로젝트를 계획하는 경우, 위키백과 API(https://www.mediawiki.org/wiki/API:Main_page)를 통해 얻을 수 있…","frontmatter":{"title":"[Python] 크롤링 - 기초 크롤러","subtitle":"","draft":false,"date":"August 30, 2022"},"fields":{"slug":"/CS/Python/2022-08-30-basic-crawler/"}}},{"node":{"id":"098e63f7-3728-572e-9af5-dfb96a1ace4f","excerpt":"기초 HTML 분석 BeautifulSoup()의 인자들 첫번째로 HTML 텍스트를 전달한다. 두번째로 BeautifulSoup가 객체를 만들때 쓰는 구문 분석기(parser)를 전달한다.\n html.parser : 별도의 C 패키지 설치 없이 사용할 수 있는 분석기 lxml : 형식을 지키지 않은 HTML 코드를 분석할 때 html.parser보다 나은 성능을 보인다. html5lib : lxml보다 다양한 에러를 수정할 수 있다. 닫히지 않은 태그, 계층 구조가 잘못된 태그를 일일이 수정한다. 신뢰할 수 있는 연결 urlope…","frontmatter":{"title":"[Python] 크롤링 - beautifulsoup 모듈","subtitle":"","draft":false,"date":"August 30, 2022"},"fields":{"slug":"/CS/Python/2022-08-30-beautifulsoup/"}}},{"node":{"id":"3a335a32-a03e-528a-b16d-40f6f741ac70","excerpt":"1. ALU ALU actions  from https://www.quora.com/What-is-ALU-in-a-computer 계산을 위해 레지스터와 제어 장치로 부터 정보를 받아들인다. 제어 장치로 부터 제어 신호를 받아들인다. (다수의) 레지스터로 부터 피연산자를 받아들인다. 받아들인 피연산자와 제어 신호로 산술 및 논리 연산을 실행한다. 결과값과 플래그를 레지스터에 저장한다. 플래그는 플래그 레지스터에, 결과값은 다른 레지스터에 저장한다. 이때 결과값은 데이터나 주소이다. CPU가 메모리에 접근하는 속도가 느리므로, 결과…","frontmatter":{"title":"[컴퓨터 구조] CPU 요소","subtitle":"","draft":false,"date":"August 30, 2022"},"fields":{"slug":"/CS/OS/2022-08-30-cs-cpu-components/"}}},{"node":{"id":"8cfa0bc2-9c7f-58a7-82e7-dafbeb8bffa8","excerpt":"Paper : Siamese Neural Networks for One-shot Image Recognition 요약 샴 신경망은 입력 데이터 쌍의 유사도를 비교하는 신경망을 학습한 뒤, 분산을 알 수 없는 새로운 샘플을 각 클래스에서 추출한 단 하나의 샘플과 비교해서 분류 작업을 수행한다. 샴 신경망은 이러한 one-shot learning에 획기적인 성과를 도출했다. 목표 : 주어진 데이터를 학습해 재학습 없이 정보가 적은 클래스에 대한 예측력을 높이고 싶다.\n{: .notice} one-shot learning ?\n각 클래스…","frontmatter":{"title":"[Paper] Siamese Neural Network, 2015","subtitle":"다양한 modality에서 활용되는 one-shot 분류 네트워크","draft":false,"date":"August 22, 2022"},"fields":{"slug":"/AI/Text/siamese-nn/"}}},{"node":{"id":"6d6651ff-87ca-564e-8233-4e9fddc3bcbd","excerpt":"Paper : Vaswani et al., 2017, \"Attention is all you need\" (Link to arxiv) 0. Transformer 트랜스포머는 RNN Seq2Seq 모델과 비슷한 인코더-디코더 구조를 갖고 있지만, 보다 긴 시퀀스를 효율적으로 다룰수 있는 모델로 환영받았다. 트랜스포머는 새로운 어텐션을 도입했다. 2014년에 등장한 어텐션(Bahdanau et al., 2014)이 RNN 네트워크의 성능을 향상시키는 활용된 것과 달리, 2017년의 어텐션은 신경망을 이용하지 않고 행렬 곱으로 이루어진 …","frontmatter":{"title":"[Paper/Trax] Transformer, 2017","subtitle":"Trax 라이브러리 코드로 Transformer를 이해해보자.","draft":false,"date":"April 14, 2022"},"fields":{"slug":"/AI/Text/transformer/"}}},{"node":{"id":"a33bcca2-a592-5fbc-b1a8-31bcab2f4d1f","excerpt":"이 글은 deeplearning.ai의 NLP Specialization를 참고하여 나이브 베이즈 모델을 텍스트 정서 분석에 초점을 맞춰 정리한 글입니다. Github에서 Naive Bayes 코드 보기 0. 모델 개략 나이브 베이즈 모델은 분류 과제를 위한 확률 모델이다. 훈련 데이터에 등장하는 모든 단어의 빈도를 세어서 각 데이터에 대한 조건부 확률의 비율을 계산하므로 분류 과제를 수행하는데 적합하다. 나이브 베이즈 모델은 훈련과 예측을 빠르게 수행할 수 있으므로 baseline 모델로 적합하다. 문장에 있는 각 단어들이 독립…","frontmatter":{"title":"텍스트 나이브 베이즈 분류","subtitle":"DL 이전의 텍스트 처리기인 나이브 베이즈 분류를 알아보자.","draft":false,"date":"April 13, 2022"},"fields":{"slug":"/AI/Text/naive-bayes/"}}},{"node":{"id":"fdb1ed87-cde0-582f-b191-1aa7075b4ed3","excerpt":"word2vec은 2013년 구글에서 고안한 자연어 처리 아이디어로, 이에 기반한 모델은 Continuous Bag-of-Words(CBOW)와 Skip-gram 두가지가 있다. 이 글은 그 중에서 CBOW 모델을 원 논문과 deeplearning.ai 수업을 참고하여 정리한 글이다. 원 논문: Mikolov et. al., 2013, Efficient Estimation of Word Representations in Vector Space (arxiv) Mikolov et. al., 2013, Distributed Repres…","frontmatter":{"title":"Word2Vec - CBOW","subtitle":"","draft":false,"date":"March 31, 2022"},"fields":{"slug":"/AI/Text/word2vec-cbow/"}}}]}},"pageContext":{}},"staticQueryHashes":["1185972000","3004417078","3231742164"],"slicesMap":{}}