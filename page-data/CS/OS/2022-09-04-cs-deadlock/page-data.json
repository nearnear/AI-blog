{"componentChunkName":"component---src-templates-blog-post-js","path":"/CS/OS/2022-09-04-cs-deadlock/","result":{"data":{"allMarkdownRemark":{"totalCount":53},"markdownRemark":{"id":"f22fc425-7d58-5bad-a051-2d6a8e8b060d","html":"<p>자원 할당 문제인 데드락에 대해 알아본다.</p>\n<br>\n<br>\n<h2>Deadlock 표현과 조건</h2>\n<h3>Dining philosopher's problem</h3>\n<p><img src=\"/d5320926715e88d2263295b8db39ecd4/cs-dining_philosopher.svg\" alt=\"\"></p>\n<p>Dining Philosopher, from <a href=\"https://www.cs.cornell.edu/courses/cs4410/2015su/lectures/lec10-deadlock.html\">https://www.cs.cornell.edu/courses/cs4410/2015su/lectures/lec10-deadlock.html</a></p>\n<p>철학자는 자신의 왼쪽과 오른쪽에 있는 젓가락을 모두 들어야 식사를 할 수 있다. 젓가락을 한번에 한명만 사용할 수 있고(mutual exclusion), 다른 철학자가 들고 있는 젓가락을 뺏을 수 없으며(no preemption), 한 젓가락을 들면 다른 젓가락을 들 수 있을 때까지 기다린다(hold and wait)고 하자.</p>\n<p>n명의 철학자가 둘러 앉아 있을때, 만약 모든 철학자의 전략이 왼쪽 젓가락을 들고 오른쪽 젓가락을 드는 것이라면 위의 그림처럼 모두 왼쪽 젓가락을 든 채 오른쪽 젓가락을 기다리는 상황이 되고(direct cycle) 결국 아무도 식사를 할 수 없는 상태로 영원히 기다리게 된다(deadlock).</p>\n<p>철학자를 프로세스 또는 스레드, 젓가락을 자원으로 바꾸어 생각하면 이 문제는 자원 할당 문제의 데드락을 마주치는 상황으로 이해할 수 있다.</p>\n<br>\n<h3>Resource-allocation graph</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 584px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 85%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAChUlEQVR42m2UaW/TQBCG+7sRH/gLiEsI8QEQQmopFKhAolRt6JGEXhEJgdTOXTeH0zinHa93/aDYcVKnWcmyPTP7zsw7xxqz4/s+y8df0q2yWdav3RZ4nofvK2wjR09P4hhZlBTxSyrUW1oS28givbg+BthqtbDHI2wtwa8PD2lfbIMUQaSRzRTA0ROcbT3COPlE06jjCrE6QjV7j1pF/qR2KOXSQeJ+iIhSof6mlkc/T1DMpgIHSqm7gJFQSsmlXkT60DI7dLvdmTzUD4dDtGIpiLpr9YKsAr1SIWCMaF+iaRqO48w9lsslfOUF//1+D13XA56jU6lUEK4z/w8iNC2HnZMW6UyRiTMO059FPBj02U1q7J23uNTL84uRfsr5XqrA/oXJcCxCwN3Ta+49OWZjrzYznvGGz8SDx+s5HjxPo12N5+lHeQkfXnzMc/9ZkozWCwGbXYc32zn+VSyWOe33+3w7KPA9bTC0xYIdpZCDPrJhcJ6psX1Upzd0WYsqa3VvaDaMeYRRXxaL+lSySNW28dpNhFHHM9v4EyfW5Gu3ASrVKoPBYEF4rYbtutMcER0TYVzhNRvI0TA2TSFF/qo+hMLvE0aXCQqHmxiZQzBNXKOO7Fn4XlhtNRlgFQ4wc7u4ndKcpljbSBkaW40y6a2n5H+8YlLNoBz3zmyrkYmRek/p51tGtUzQr/PRiz6mvXfdbIPdIfP1JeWDdwhTmxcgiiBwPurQPPtM7XiDSSPPRHgoJZdmeVrZwHsH4/QL5eNNhFlcuW2mNo2zz1SP1nGbf6OVE095sU0kSBeUQM1ouAM4bGOk1intv8a9zsaWxwLw9sUVuzAGKByEdYU3fcbdWFH+A4VIFrkG8bpUAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cs deadlock\"\n        title=\"\"\n        src=\"/static/1a90b40fcca9e765fdd03e4ad4f5b19d/e05eb/cs-deadlock.png\"\n        srcset=\"/static/1a90b40fcca9e765fdd03e4ad4f5b19d/5a46d/cs-deadlock.png 300w,\n/static/1a90b40fcca9e765fdd03e4ad4f5b19d/e05eb/cs-deadlock.png 584w\"\n        sizes=\"(max-width: 584px) 100vw, 584px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Resource Allocation Graph, from <a href=\"https://velog.io/@dltmdrl1244/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-Ch07-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C-Deadlock\">here</a></p>\n<p>자원할당 그래프는 프로세스(또는 스레드)가 점유하고 있는 자원과 대기중인 자원을 나타내는 그래프이다.</p>\n<ul>\n<li>프로세스(또는 스레드)는 원으로, 자원은 사각형으로 표현한다.</li>\n<li>사용 가능한 자원의 개수를 사각형 내의 점으로 표현한다.</li>\n<li>프로세스가 자원을 점유중인 것은 자원에서 프로세스로 향하는 화살표로 표현한다.</li>\n<li>프로세스가 자원을 기다리는 것을 프로세스에서 자원으로 향하는 화살표로 표현한다.</li>\n</ul>\n<br>\n<h3>Necessary conditions</h3>\n<p>데드락은 네가지 조건을 만족되면 발생한다.</p>\n<ul>\n<li>Mutual exclusion : 자원을 배타적으로 사용한다.</li>\n<li>Hold and wait : 자원을 점유하고 필요한 자원이 가능할때까지 대기한다.</li>\n<li>Non-preemptive : 자원을 선점하지 않는다. 즉 실행중인 자원을 뺏을 수 없다.</li>\n<li>Circular wait : 자원 할당 그래프에 사이클이 존재한다.</li>\n</ul>\n<br>\n<br>\n<h2>Deadlock 대처 방안</h2>\n<h3>Deadlock Prevention</h3>\n<p>데드락의 필요 조건 중 하나가 충족되지 않는다면 데드락을 예방할 수 있다.</p>\n<ul>\n<li>상호 배제 조건의 제외는 원칙적으로 불가능하다.</li>\n<li>점유와 대기 조건을 충족하지 않으려면 OS는 특정 프로세스가 요구하는 자원을 동시에 사용할 수 있도록 해야한다. 따라서 할당되어도 사용되지 않는 자원이 생길 것이며 많은 자원을 사용하는 프로세스는 대기 시간이 무한정 길어질 수 있다.</li>\n<li>비선점 조건을 충족하지 않으려면 자원을 사용하는 도중에 가로챌 수 있어야 한다. CPU의 경우 time slice 등으로 비선점 조건을 충족할 수 있지만, 입출력 장치 중 많은 경우는 선점이 불가능하다.</li>\n<li>원형 대기 조건을 충족하지 않기위해 모든 자원에 번호를 매겨 오름차순으로 자원을 할당할 수 있다. 그렇지만 번호를 매기는 순서에 따라 자원의 활용율이 달라지는 문제가 발생한다.</li>\n</ul>\n<br>\n<h3>Deadlock Avoidance</h3>\n<p>데드락을 피하기 위해 안전 상태를 유지하도록 자원을 할당할 수 있다.</p>\n<ul>\n<li>안전 상태(safe state)란 모든 프로세스가 자원을 할당받고 실행 된 후 데드락 없이 종료될 수 있는 상태이다.</li>\n<li>안전 순서열(safe sequence)은 데드락이 발생하지 않도록 자원을 할당하는 프로세스 순서이다.</li>\n<li>불안전 상태(unsafe state)는 안전 순서열이 없는 상황이다. 시스템이 불안전 상태에 있으면 데드락이 발생할 위험이 있다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 662px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAHABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB2wQH/8QAFhABAQEAAAAAAAAAAAAAAAAAAQAQ/9oACAEBAAEFAgYHP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAQADAQAAAAAAAAAAAAAAAAAhMUGR/9oACAEBAAY/ArS3r//EABgQAAMBAQAAAAAAAAAAAAAAAAABESFB/9oACAEBAAE/IVW6FbQt4H//2gAMAwEAAgADAAAAEAAP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGBABAAMBAAAAAAAAAAAAAAAAAQARIUH/2gAIAQEAAT8QWbhEN7Lm6JmwosWP/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cs safe state\"\n        title=\"\"\n        src=\"/static/b43b15fb104ab60d51fc203a548d0ed9/7bfef/cs-safe_state.jpg\"\n        srcset=\"/static/b43b15fb104ab60d51fc203a548d0ed9/f93b5/cs-safe_state.jpg 300w,\n/static/b43b15fb104ab60d51fc203a548d0ed9/b4294/cs-safe_state.jpg 600w,\n/static/b43b15fb104ab60d51fc203a548d0ed9/7bfef/cs-safe_state.jpg 662w\"\n        sizes=\"(max-width: 662px) 100vw, 662px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Safe state, from <a href=\"https://www.cs.fsu.edu/~liux/courses/cop5611/notes/deadlock.html\">https://www.cs.fsu.edu/~liux/courses/cop5611/notes/deadlock.html</a></p>\n<ul>\n<li>Claim Matrix에서 프로세스 P1, P2, P3, P4가 자원 R1, R2, R3를 요구하고 있고, Allocation Matrix는 현재 할당된 상태를 의미한다.</li>\n<li>Resource Vector가 할당이 가능한 자원의 전체 수를 의미하고, Available Vector는 Allocation Matrix에 할당하고 남은 가용 자원을 의미한다.</li>\n<li>이때 (P2 - P3 - P4 - P1)는 안전 순서열이다.\n<ul>\n<li>P2에 R1 하나와 R3 두개를 할당하면 P2를 종료할 수 있고, 반환된 자원(R1: 6, R2: 2, R3: 3)을 P3에 할당해 마찬가지로 P3를 종료할 수 있다. 같은 과정으로 P4와 P1을 종료할 수 있다.</li>\n</ul>\n</li>\n<li>반면, P1에 R1과 R3를 하나씩 할당하면 가용 자원은 R2와 R3 하나씩이 남게된다. 이때 R2와 R3를 하나씩 할당해서 완료할 수 있는 프로세스가 없으므로 시스템은 불안전 상태에 놓이게 된다.</li>\n</ul>\n<br>\n<h3>Deadlock Recovery</h3>\n<p>데드락을 예방하거나 회피하지 않고 데드락이 발생한 상황을 사후적으로 감지하고 대처하는 방식으로 대응할 수 있다.</p>\n<ul>\n<li>첫번째 방법은 데드락이 해결될 때까지 선점을 통해 특정 프로세스에 자원을 몰아주는 것이다. 선점이 가능한 자원에 대해서만 실행이 가능하며 데드락을 확인하는데에 오버헤드가 발생할 수 있다.</li>\n<li>두번째 방법은 프로세스를 강제 종료하는 것이다. 모든 프로세스를 강제 종료하면 확실하게 데드락을 해소할 수 있지만 모든 작업 내역을 잃을 것이고, 데드락이 해소될 때까지 프로세스를 하나씩 강제 종료한다면 작업 내역을 잃는 것은 줄일 수 있지만 데드락을 확인하는데에 오버헤드의 가능성이 생긴다.</li>\n</ul>\n<br>\n<h3>Ignoring deadlock</h3>\n<p>앞서 다룬 방법들이 오버헤드를 야기할 가능성이 큰데 비해 데드락이 발생할 가능성이 적다고 해보자. 그렇다면 데드락에 대처하는 것보다 데드락의 가능성을 무시하는 것이 더 시스템 효율적이다.</p>\n<ul>\n<li>문제에 대처하는 비용이 문제를 마주치는 비용보다 클 경우, 문제가 일어나지 않을 것이라고 가정하는 전략을 Ostrich alorithm이라고 한다.</li>\n</ul>\n<br>\n<h3>참고자료</h3>\n<ul>\n<li>『혼자 공부하는 컴퓨터 구조 + 운영체제』, 강민철, 한빛미디어</li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","frontmatter":{"title":"[OS] 데드락","date":"September 04, 2022"}}},"pageContext":{"slug":"/CS/OS/2022-09-04-cs-deadlock/","previous":{"fields":{"slug":"/CS/OS/2022-09-04-cs-cpu-scheduling/"},"frontmatter":{"title":"[OS] CPU 스케줄링"}},"next":{"fields":{"slug":"/CS/OS/2022-09-06-cs-virtual-memory-1/"},"frontmatter":{"title":"[OS] 가상 메모리(Virtual Memory)와 페이징(Paging)"}}}},"staticQueryHashes":["1185972000","3231742164"],"slicesMap":{}}