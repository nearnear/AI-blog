{"componentChunkName":"component---src-templates-blog-post-js","path":"/CS/OS/2022-08-30-cs-instruction-2/","result":{"data":{"allMarkdownRemark":{"totalCount":45},"markdownRemark":{"id":"9bfa2d14-feea-5f51-a731-08db00e724b0","html":"<h2>명령어 사이클</h2>\n<p>CPU는 프로그램에서 전달받은 명령어를 <strong>하나씩</strong> 실행한다. 이 명령어들은 정형화된 흐름을 반복하며 실행되는데,\n이 흐름을 명령어 사이클(instruction cycle)이라고 한다. 즉 프로그램의 명령어들은 명령어 사이클이 반복되며 실행된다고 볼 수 있다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 45.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+UlEQVR42mWRW08aURSF+dUmTdOmabUlikYZYMCxffBBa2KbKGkR4xQttxkYqK0UtDiDjtBiuTUF5KL4NTNeqvFh55yc7PXtfdZyXKb83C3SAXpxD8fBCUrr4xwFxzHWXnC66QJtnpHqZ5TyM1LF+7qUyEh7jcMCWI23lQ7Ygl52iSNZoiRL9v1mGBkJshLsLkBm/gpovVtDLOBQ8dGOeujEvLRjHs4VH7+2ZmnUqhSKBgeGSav2k0rIacPKG1MYQSe7K8+obEzeQm+B3agb/d0TDt8/Jbs4xmn4FY3IHHV1mUZmlZP4Eo3UW2pb09Q3neSWH5FfeYy2OEbVsiEj3QcOVIlhOUtR/Uhlb4fGtxAXipdB3E1nZ4b29jSjpMC5ItLMy5x8jaBrm5zpcf7suLlQRduKyxsPO8oCjdop+4U8pWOT6g+Npuzi72c3rcgszcgsnahAa3uOZrnIoW5gGAaV0gFmaOoh0Fr3XPXTT/psseWjZXo35qEuz9CJCXZIVmCW181tt917oV6nm/kfJtk3OLj+P+mrFAcJD1V5DlMvkMvl2N8vUNa/Uw1P0k94Gak+LlWRQcJLNyrQjQn22Y8L9JIBHFbkdwstQF/x8zv3iZNdGfOLTG1vi0HSy1ARaUcFzuIeKmEX+dXnHK6/pLg2gfnBibkxwz8lg1hmSNI8AQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cs instruction cycle\"\n        title=\"\"\n        src=\"/static/f8b8a27d1267507163fe810465b824b1/c1b63/cs-instruction-cycle.png\"\n        srcset=\"/static/f8b8a27d1267507163fe810465b824b1/5a46d/cs-instruction-cycle.png 300w,\n/static/f8b8a27d1267507163fe810465b824b1/0a47e/cs-instruction-cycle.png 600w,\n/static/f8b8a27d1267507163fe810465b824b1/c1b63/cs-instruction-cycle.png 1200w,\n/static/f8b8a27d1267507163fe810465b824b1/a2792/cs-instruction-cycle.png 1462w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Instruction cycle: the process a CPU executes a program.</p>\n<p>가능한 경우 인출 사이클과 실행 사이클을 오가면서 순차적으로 프로그램을 실행하고, 인출 사이클에서 실행 사이클을 갈 수 없는 경우 (간접 사이클)와 실행 사이클에서 인출 사이클로 갈 수 없는 경우 (인터럽트 사이클) 흐름이 바뀌는 것을 확인할 수 있다.</p>\n<br>\n<h3>명령어 사이클의 종류</h3>\n<p>명령어 사이클은 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있다. 인터럽트 사이클은 다시 예외와 하드웨어 인터럽트로 나뉠 수 있다.</p>\n<h4>인출 사이클 (fetch cycle)</h4>\n<p>프로그램을 실행하기 위해 먼저 명령어를 메모리에서 CPU로 가져오는 과정이다.</p>\n<h4>실행 사이클 (exceution cycle)</h4>\n<p>CPU로 가져온 명령어를 실행하는 단계이다. 제어 장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시킨다.</p>\n<h4>간접 사이클 (indirect cycle)</h4>\n<p>인출 사이클에서 실행 사이클로 진행하고자 할 때, 명령어를 실행하기 위한 조건이 만족되지 않았을 때 이를 만족하기 위해 추가되는 사이클이다. 예를 들어 명령어의 오퍼랜드에 간접 주소 지정 방식을 사용하는 경우 레지스터에 담긴 값은 유효 주소의 주소 값이므로 유효 주소를 얻기 위해 메모리를 한번 더 인출해야 한다.</p>\n<p><strong>인터럽트</strong>란 CPU의 작업을 방해하는 신호이다. 인터럽트는 크게 CPU 내부에서 발생시키는 예외와 CPU 외부에서 발생시키는 하드웨어 인터럽트로 나눌 수 있다.</p>\n<h4>예외 (exception, synchronous interrupt)</h4>\n<ul>\n<li>CPU에 의해 발생하는 인터럽트로, CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트이다.</li>\n<li><a href=\"https://docs.python.org/3/library/exceptions.html\">파이썬의 Exception 클래스</a> 를 참고할 수 있다.</li>\n</ul>\n<h4>하드웨어 인터럽트 (hardware interrupt, asynchronous interrupt)</h4>\n<ul>\n<li>입출력장치에 의해 발생하는 인터럽트를 하드웨어 인터럽트라 한다. 비동기 인터럽트는 주로 입출력장치에 의해 발생하지만, CPU에 의해 발생하지 않는 모든 인터럽트를 포함한다. (예를 들면 전원 차단 등)</li>\n<li>CPU는 하드웨어 인터럽트를 명령어를 효율적으로 처리하는데에 사용할 수 있다. 예를 들어 CPU가 입출력 작업의 결과값이 필요한 경우, 입출력 작업이 끝나기 전까지 직접 입출력 장치에 접근하는 대신 입출력 장치에서 처리가 완료된 경우에 인터럽트를 받도록 할 수 있다.</li>\n</ul>\n<br>\n<h3>하드웨어 인터럽트 처리 순서</h3>\n<ol>\n<li>입출력 장치는 CPU에 <strong>인터럽트 요청 신호</strong> 를 보낸다.</li>\n<li>CPU는 실행 사이클이 끝나고 명령어를 인출(fetch)하기 전 항상 인터럽트 여부를 확인한다.</li>\n<li>CPU가 인터럽트 요청을 확인하고 <strong>인터럽트 플래그</strong> 를 통해 현재 인터럽트를 받아들일 수 있는지 확인한다.\n<ul>\n<li>인터럽트 플래그는 플래그 레지스터에 있는 비트 정보다.</li>\n<li>만약 플래그가 비활성되어 있으면 인터럽트를 무시할 수 있다.</li>\n<li>그렇지만 하드웨어 인터럽트 중에는 막을 수 없는 인터럽트(non-maskable interrupt)도 있는데, 이런 인터럽트는 플래그에 관계없이 무시할 수 없다. 예를 들어 전원 차단이나 하드웨어 고장의 경우 플래그와 관계없이 프로그램이 중단될 수 있다.</li>\n</ul>\n</li>\n<li>인터럽트를 받아들일 수 있으면, CPU는 지금까지의 작업을 메모리의 스택 영역에 백업한다.</li>\n<li>CPU는 <strong>인터럽트 벡터</strong> 를 참조해 <strong>인터럽트 서비스 루틴(ISR or iterrupt handler)</strong> 을 실행한다.\n<ul>\n<li>인터럽트 벡터는 CPU가 요청 신호를 보낸 대상에게 받는 정보로, ISR의 시작 주소를 담고있다.</li>\n<li>ISR은 인터럽트 발생시에 처리하거나 작동할 정보를 담은 프로그램이다. 즉 메모리 영역에 있다.</li>\n</ul>\n</li>\n<li>인터럽트 서비스 루틴 실행이 끝나면 4번 과정에서 백업했던 작업을 복구해 실행을 재개한다.</li>\n</ol>\n<br>\n<h3>참고자료</h3>\n<ul>\n<li>『혼자 공부하는 컴퓨터 구조 + 운영체제』, 강민철, 한빛미디어</li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n</style>","frontmatter":{"title":"[컴퓨터 구조] CPU 명령어 사이클","date":"August 30, 2022"}}},"pageContext":{"slug":"/CS/OS/2022-08-30-cs-instruction-2/","previous":{"fields":{"slug":"/CS/OS/2022-08-30-cs-instruction-1/"},"frontmatter":{"title":"[컴퓨터 구조] CPU 명령어(Instruction)"}},"next":{"fields":{"slug":"/CS/Git/git-rebase/"},"frontmatter":{"title":"[Git] git rebase로 잔디 회복하기"}}}},"staticQueryHashes":["1185972000","3231742164"],"slicesMap":{}}