{"componentChunkName":"component---src-templates-blog-post-js","path":"/CS/OS/2022-09-03-cs-process-n-thread/","result":{"data":{"allMarkdownRemark":{"totalCount":53},"markdownRemark":{"id":"f88bf9b8-1001-5519-a5ee-9c4dcd81d7d6","html":"<h2>Process</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABK0lEQVR42nWR266CQAxF5/9/TUh40nCVq4SbCgEFovZkNRneTpNmOtN2d3ePKctSbreb5Hku1+tVY9/39f54PGSeZ+n7Xuq61vj3+8l/Rs5s2yZd18myLLLvuzRNI6fTSYExQC6XiyRJIkEQaMzg5/Mp67oeTi9mxnGUOI6VwTRNAmPHcaQoCi2gME1THcQbwFmWKSjvNq6qSu73uxiCKIoUCFDAPc/TIgYMw6AS0EyOWk4bM4BhbNm0jRgarHaWxfl8VoD3+y1IgoasSFPbtofzXlWlao0rQ7sSSbSApeu6x8oAoh13PgpW9gOpR+Pv93t8jGEy66IlCRjDEAYYTRaQ9VgVMO4wwumxp4Eq66IXgCQAgLFlGIahDoA9nwAYwAAgw+v10t7P5yN/NcFWXQ/KMc4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cs in process\"\n        title=\"\"\n        src=\"/static/a627b93dc98c372b46138f4516401a5d/c1b63/cs-in_process.png\"\n        srcset=\"/static/a627b93dc98c372b46138f4516401a5d/5a46d/cs-in_process.png 300w,\n/static/a627b93dc98c372b46138f4516401a5d/0a47e/cs-in_process.png 600w,\n/static/a627b93dc98c372b46138f4516401a5d/c1b63/cs-in_process.png 1200w,\n/static/a627b93dc98c372b46138f4516401a5d/af756/cs-in_process.png 1639w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>사용자가 보는 곳에서 실행되는 프로세스는 foreground process,</li>\n<li>사용자가 보지 못하는 곳에서 실행되는 프로세스는 background process라고 한다.\n<ul>\n<li>background process 중 사용자와 상호작용하지 않는 프로세스를 daemon(유닉스 체계 OS) 또는 service(윈도우 OS)라고 부른다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h3>PCB; Process Control Block</h3>\n<p>OS의 PCB란 프로세스의 실행 순서와 자원 배분을 관리하는 자료 구조이다. PCB는 커널 영역에 생성되며, 프로세스를 실행하기 위해 필요한 정보를 저장한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 30.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA9UlEQVR42m2RB4qEUBBEvf/tVMzimEdMY06otVQvwrCsIDT2/6+CSlEUyPMcaZqirmu8Xi9EUYQ4jpEkiezatsW6rbjvG9d1oWkarOuK8zyRZRnKssQwDNi2DcqyLKiqCsdxyOIB6LoO0zRFYBxH9H0vMD6c+W3fd7iuC8/zYFmWGFGmacL7nQudrui06zqoqipQAunmG0gY7xEYBIFADcNAGIZQ5nkWCJeMzAg8rGmavFRlCkb6C2Qq3/cFaNv2L5CLB8jInPuhF4eO40iPPPMN5PxEJojApx7l8/mAP4Zq7JId8gLjshcKMMV/DgmkKF0+Hf4AI+rBZlcvfuoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cs process priority\"\n        title=\"\"\n        src=\"/static/6cd89a1057b545b3c5a3681c6088a2f9/c1b63/cs-process_priority.png\"\n        srcset=\"/static/6cd89a1057b545b3c5a3681c6088a2f9/5a46d/cs-process_priority.png 300w,\n/static/6cd89a1057b545b3c5a3681c6088a2f9/0a47e/cs-process_priority.png 600w,\n/static/6cd89a1057b545b3c5a3681c6088a2f9/c1b63/cs-process_priority.png 1200w,\n/static/6cd89a1057b545b3c5a3681c6088a2f9/d61c2/cs-process_priority.png 1800w,\n/static/6cd89a1057b545b3c5a3681c6088a2f9/14747/cs-process_priority.png 1914w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>다음은 PCB에 저장되는 정보들이다.</p>\n<ul>\n<li>PID; Process ID\n<ul>\n<li>같은 프로그램을 실행하더라도 매번 새롭게 할당되는 프로세스 식별 번호이다.</li>\n</ul>\n</li>\n<li>레지스터 값; Register Values\n<ul>\n<li>CPU가 프로세스를 다시 실행할 수 있도록 실행 상태에서 사용한 레지스터의 값을 저장한다.</li>\n<li>프로그램 카운터와 레지스터 값이 담긴다.</li>\n</ul>\n</li>\n<li>프로세스 상태; Process State\n<ul>\n<li>프로세스의 상태를 저장한다.</li>\n<li>프로세스가 준비 상태인지 실행 상태인지 또는 대기 상태인지 알 수 있다.</li>\n</ul>\n</li>\n<li>CPU 스케줄링 정보; Process priority\n<ul>\n<li>프로세스가 언제, 어떤 순서로 CPU를 할당 받을지를 저장한다.</li>\n</ul>\n</li>\n<li>메모리 관리 정보\n<ul>\n<li>프로세스가 메모리에 저장된 주소가 담긴다.</li>\n<li>베이스 레지스터, 한계 레지스터 값과 페이지 테이블 정보가 담긴다.</li>\n</ul>\n</li>\n<li>List of Open Files\n<ul>\n<li>프로세스가 실행 상태에서 사용한 파일 목록이 담긴다.</li>\n</ul>\n</li>\n<li>List of I/O devices\n<ul>\n<li>프로세스가 실행 상태에서 사용한 입출력 장치의 목록이 담긴다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h3>문맥 교환; Context Switching</h3>\n<ul>\n<li>문맥(context)은 프로세스를 실행하기 위한 정보로, PCB에 표현된다.</li>\n<li>문맥 교환(context switching)은 프로세스를 전환하기 위해, 기존 프로세스의 문맥을 PCB에 백업하고 새로운 프로세스의 PCB에서 문맥을 복구하여 실행하는 것을 의미한다.</li>\n<li>문맥 교환을 통해 여러 프로세스가 빠르게 번갈아가며 실행되지만, 너무 자주 하면 overhead가 일어날 수 있다.</li>\n</ul>\n<br>\n<h3>프로세스의 메모리 영역</h3>\n<p>메모리에서 프로세스는 크게 (스택 영역, 힙 영역, 데이터 영역, 코드 영역) 네가지로 구성된다.</p>\n<ul>\n<li>이 중에서 스택 영역과 힙 영역은 가변적이기 때문에 동적 할당 영역(dynamic allocation segment)이라고 하고,</li>\n<li>데이터 영역과 코드 영역은 정적 할당 영역(static allocation segment)이라고 한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 499px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 92%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAIAAADUsmlHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB10lEQVR42o2TW6+qMBBG/f8/yxcTjT6IiNa2UNqC2JYWb4VyOwnNMTv7qDnrCULWTOebMuv7XghBCOGcM8aMMeN/MxvHcRgGrbX3tdbGGDFRFIUxRinVdd1HeRzHvu/rur7dblmWGWMopcfj0R+EENI0je/xXvYf2rYVQlwnKKXGmMfjkWWZEEIpxRh7L3vatiWEpGlKCAmCgE4AAKy1fd/7/h/lruuSJEnTlFLqSzDGAAD/au9ljDEAAGOMEMIYQwgBAM65b2m/ZqaUrlar+Xy+XC4Xi8V6vUYIfZN/zsw5hxCGYRhFURiGcRwnSfJRHobBWluWJYQwjuPT6YQQiifwRBAE31ZVlqUQQkqplDocDsHEZrMJgmC73e52u7Zt33fuui7Pc1+167o0TdlEGIac8yzLIITX67WqKsbYr/PP6rpO09S/OOeklPf7vaqqOI611tbaPM+VUnVdK6V+d3bOcc5fMmMMY7zf748TfuyPe3bO5Xn+SptSej6ffdRRFBVFgRCy1r4PrGkaxljf92VZSikJIRDC3UQURQghfz1/Oq8qs7ZttdZN0yRJQin1G0om/JIBAB/Tfj6fGGN/jYuiEELkE/65+IvWWkp5uVz8H5Zlmdb6D/pu+j97S3I1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cs process in memory\"\n        title=\"\"\n        src=\"/static/d738c9fb98134edf66f8dcdc23f3d0cf/119c7/cs-process_in_memory.png\"\n        srcset=\"/static/d738c9fb98134edf66f8dcdc23f3d0cf/5a46d/cs-process_in_memory.png 300w,\n/static/d738c9fb98134edf66f8dcdc23f3d0cf/119c7/cs-process_in_memory.png 499w\"\n        sizes=\"(max-width: 499px) 100vw, 499px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>from <a href=\"https://medium.com/powerof2/memory-library-in-kernel-3f8b1fbda161\">https://medium.com/powerof2/memory-library-in-kernel-3f8b1fbda161</a></p>\n<ul>\n<li>스택 영역(stack segment)\n<ul>\n<li>데이터를 일시적으로 저장하는 영역</li>\n<li>매개 변수, 지역 변수, 재귀 함수의 결과값 등이 저장된다.</li>\n</ul>\n</li>\n<li>힙 영역(heap segment)\n<ul>\n<li>사용자가 직접 메모리를 할당할 수 있는 영역</li>\n<li>메모리를 할당 후 반환하지 않으면 memory leakage가 발생하는 곳이다.</li>\n</ul>\n</li>\n<li>데이터 영역(data segment)\n<ul>\n<li>프로그램이 실행되는 동안 유지할 데이터를 저장하는 영역</li>\n<li>전역 변수가 저장된다.</li>\n</ul>\n</li>\n<li>코드 영역(code or text segment)\n<ul>\n<li>기계어 명령어를 저장하는 영역</li>\n<li>읽기 전용 read-only 공간이다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h3>프로세스 상태; Process state</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABJElEQVR42mWR62rCQBCF8/7P1FKh0B+VoqBQtVWkGhtNN5vN5rZJdr+SNb2oAwszZ88ZZs4EnXU457gI5+hxnCXPc6Iooq5rrO2wnnrJd/+QYLTMmO4q4iTlEIacvgTTj4LRQjHfaZRSaJ0Ri4Tnd8nDa8ris+R4PHII94QnyeNCcj+L2YuKoG/2djJUdUPbNlS1YR0bnpaCVaiQUnpxqjJWUcl4o9glhqYxNMag8prZvmCy1cSZIcD9DWyt82vhOmSSUOQZXdf5ta21ZEpSlgXY7sqmvzwYLPOEsixJ09S/REqEELRt64llUfhaa+3/ek/PWnfWD3lwBq6OMoRpO8Zrxd1cMNmI22MMup8evw2vQTfY0F+69/Nlqwll61e55HAzzDdZox3XeGnZQgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cs process state diagram\"\n        title=\"\"\n        src=\"/static/5f983387d860140d6067e958c855ede7/c1b63/cs-process_state_diagram.png\"\n        srcset=\"/static/5f983387d860140d6067e958c855ede7/5a46d/cs-process_state_diagram.png 300w,\n/static/5f983387d860140d6067e958c855ede7/0a47e/cs-process_state_diagram.png 600w,\n/static/5f983387d860140d6067e958c855ede7/c1b63/cs-process_state_diagram.png 1200w,\n/static/5f983387d860140d6067e958c855ede7/a2792/cs-process_state_diagram.png 1462w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Process state diagram, from <a href=\"https://medium.com/@sohailk1999/five-state-process-model-6e83d7428c8c\">https://medium.com/@sohailk1999/five-state-process-model-6e83d7428c8c</a></p>\n<ul>\n<li>생성 상태(new)\n<ul>\n<li>프로세스가 메모리에 적재되어 PCB를 할당받은 상태</li>\n<li>생성 상태를 거쳐 준비 상태가 되어 CPU의 할당을 기다린다.</li>\n</ul>\n</li>\n<li>준비 상태(ready)\n<ul>\n<li>CPU를 할당받아 실행할 수 있지만, 대기하고 있는 상태</li>\n<li>준비 상태 프로세스는 차례가 되면 CPU를 할당받아 실행 상태가 된다.</li>\n<li>프로세스가 준비 상태에서 실행 상태로 전환되는 것을 dispatch라고 한다.</li>\n</ul>\n</li>\n<li>실행 상태(running)\n<ul>\n<li>CPU를 할당받아 실행 중인 상태</li>\n<li>할당된 일정 시간 동안 프로세스가 종료되지 않으면, 타이머 인터럽트가 발생해 다시 준비 상태가 된다.</li>\n<li>실행 상태인 프로세스가 I/O device를 사용하는 경우, I/O device의 작업이 끝날 때까지 대기 상태가 된다.</li>\n</ul>\n</li>\n<li>대기 상태(blocked)\n<ul>\n<li>특정 이벤트가 일어나길 기다리는 상태</li>\n<li>주로 I/O device의 작업이 끝나 입출력 완료 인터럽트를 받기를 기다리는 상태이다.</li>\n<li>입출력 작업이 완료되면 프로세스는 다시 준비 상태가 된다.</li>\n</ul>\n</li>\n<li>종료 상태(terminated)\n<ul>\n<li>프로세스가 종료된 상태</li>\n<li>OS는 종료 상태인 프로세스의 메모리와 PCB를 정리한다.</li>\n</ul>\n</li>\n</ul>\n<br>\n<h3>프로세스 계층 구조; Process hierachy</h3>\n<p>실행 상태의 프로세스는 system call을 통해 다른 프로세스를 생성할 수 있다.</p>\n<ul>\n<li>이때 새 프로세스를 생성한 프로세스를 부모 프로세스(parent process),</li>\n<li>부모 프로세스에 의해 생성된 프로세스를 자식 프로세스(child process)라고 한다.</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 42%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABK0lEQVR42o2R6Y6CQBCEef9Xg0QQORUJAqIcCirGg6Q3XycYN/tnJ6nMdM9MVXW3kee5OI4jm81GkiSRKAolCALZbrfStq28Xi+53+/yfD7lP8u4Xq/ieZ5EUST7/V5Jfd/XOAxDzYHD4SBFUcg4jvJ+v1Xg8XgoOAPyxjAM4rqufi7LUsk54xJwRwW2bctyudQcbwB3YH4Xx7EYfd+ro8VioQ5wRswlJDher9dKisvZcdM0agDMua7rxLhcLqoGYZZlHzVIIaTHlEM/Eec9baKy2+2mMSDWks/ns1iW9XG4Wq0UiECICOoQn04n/cgOpmn6OxRUIYNgt9tpyXOvTNPUkquqUoffg/gexq+hYBcCiNI0VeI5xiFuj8ejUAmu6B3kYD7Xda07rfgBl15OEwzyUHMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cs pstree\"\n        title=\"\"\n        src=\"/static/242d66625624116334f67e0e93c9fae8/c1b63/cs-pstree.png\"\n        srcset=\"/static/242d66625624116334f67e0e93c9fae8/5a46d/cs-pstree.png 300w,\n/static/242d66625624116334f67e0e93c9fae8/0a47e/cs-pstree.png 600w,\n/static/242d66625624116334f67e0e93c9fae8/c1b63/cs-pstree.png 1200w,\n/static/242d66625624116334f67e0e93c9fae8/d1882/cs-pstree.png 1562w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Process state tree</p>\n<ul>\n<li><em>mac OS의 최초 프로세스는 launchd이며, PID는 1이다.</em></li>\n<li>부모 프로세스와 자식 프로세스는 각각의 PID를 가진다.\n<ul>\n<li>유닉스 OS에서는 부모 프로세스의 PID인 PPID를 기록한다.</li>\n</ul>\n</li>\n<li>자식 프로세스는 다시 프로세스를 생성할 수 있으므로, 프로세스가 계층 구조를 이루게 된다.</li>\n</ul>\n<br>\n<h3>프로세스 생성 방법</h3>\n<p>프로세스는 시스템 호출인 fork와 exec를 통해 자식 프로세스를 생성한다.</p>\n<ul>\n<li>fork는 프로세스의 복사본을 만드는 시스템 호출로, 부모 프로세스는 fork를 통해 자신의 복사본을 자식 프로세스로 생성한다.</li>\n<li>exec는 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출로, 자식 프로세스는 exec를 통해 메모리 공간을 다른 프로그램의 데이터와 명령으로 교체한다.</li>\n</ul>\n<p>예를 들어 bash 셸에서 ls 라는 명령어를 입력한 경우,</p>\n<ul>\n<li>셸 프로세스는 fork를 통해 자신을 복사한 프로세스를 생성하고,</li>\n<li>복사된 프로세스는 exec를 통해 ls 명령어를 실행하기 위한 프로세스로 전환된다.</li>\n<li>메모리에는 ls 명령어를 실행하는 내용이 채워진다.</li>\n</ul>\n<br>\n<br>\n<h2>Thread</h2>\n<p>스레드란 프로세스를 구성하는 실행 단위이다. 즉 하나의 프로세스에 여러개의 스레드가 있을 수 있고, 이 프로세스를 멀티스레드 프로세스라고 한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 70.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRmIAAABXRUJQVlA4IFYAAADwAwCdASoUAA4APtFUpEuoJKOhsAgBABoJZwCsACHcVqn9m/6+2dSwAP7wEKrqp1crwFo716dVjL+XyWAMc7dQ9EbmLDusGqRZWHIK7YC7eeeqEkAAAA=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cs thread processes\"\n        title=\"\"\n        src=\"/static/fd568ec70a49c9a8c4727c0c936d3ef3/e88ff/cs-thread_processes.webp\"\n        srcset=\"/static/fd568ec70a49c9a8c4727c0c936d3ef3/c85cb/cs-thread_processes.webp 300w,\n/static/fd568ec70a49c9a8c4727c0c936d3ef3/e88ff/cs-thread_processes.webp 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>Single Process vs. Multi Process, from <a href=\"https://ethicalhacking424.wordpress.com/2015/12/09/multi-threading/\">https://ethicalhacking424.wordpress.com/2015/12/09/multi-threading/</a></p>\n<p>스레드는 프로세스 자원을 공유하며 실행에 필요한 최소한의 정보로만 실행된다.</p>\n<ul>\n<li>스레드는 프로세스 내에서 각각 다른 (스레드 ID, 프로그램 카운터, 레지스터 값, 스택 메모리)로 구성된다.</li>\n<li>따라서 각자 다른 코드를 실행할 수 있다.</li>\n<li>반면 프로세스의 (코드, 데이터, 힙 메모리) 자원을 공유한다.</li>\n</ul>\n<h4>[참고] 리눅스는 프로세스와 스레드를 구분없이 task로 일컫는다.</h4>\n<pre class=\"grvsc-container abyss\" data-language=\"\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">Both threads and processes are really just one thing: a &quot;context of</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">execution&quot;. Trying to artificially distinguish different cases is just</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">self-limiting.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">...</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">The way Linux thinks about this (and the way I want things to work) is that</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">there _is_ no such thing as a &quot;process&quot; or a &quot;thread&quot;. There is only the</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">totality of the COE (called &quot;task&quot; by Linux). Different COE&#39;s can share parts</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">of their context with each other, and one _subset_ of that sharing is the</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">traditional &quot;thread&quot;/&quot;process&quot; setup, but that should really be seen as ONLY</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">a subset (it&#39;s an important subset, but that importance comes not from</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">design, but from standards: we obviusly want to run standards-conforming</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">threads programs on top of Linux too).</span></span></code></pre>\n<p><a href=\"https://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html\">https://lkml.iu.edu/hypermail/linux/kernel/9608/0191.html</a> by Linus Torvalds</p>\n<br>\n<h3>Multiprocess vs. MultiThread</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABdElEQVR42n1Ti47DIAzr/3/o1tJu3cobqvrkjKDedjukCFqMceIw5JyRUoKO4zg+A8C+74gx/o87DgwxJjgf4H1AzgXfRq0Vznn4EMEz38YQGqF1HiFElFKFWCPlLOpIuFknOGv9L4xGrTuG9bHBzDdM5gYz3zGaRdTyIBVxJhkPXEaD5+YgIlyQfZn9K1LKVBj7D029lCJKSyPiTJUk5yG9QDClShacJWUqpKpxWrDcVlHLtfwzC56blQMk4vfEfbPgOs6CvU4zyMF9IeSCtWOxwyl8U6xGsT6+4bj3wiUxiBdqHYf7+pRbeBtrxG9uaJ1IwBGpcJql1lRpJBaZ7+tD8CTubaMqY0py+NxC7C8qJLZnETM2V+F97CrFZW6qGRIhSvG51mbVlM9Y5zPmtcA2l9lK4rJvIGkBH8QEOvr+GuiibRjFlZL/bmxNV1KP6eM5nU3p7SXmxG4Uy9SfHkkUrM/qnZD9ehnn7j6/u+uNkAp/AGCW9CXpuF/nAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cs multiprocessing multithreading\"\n        title=\"\"\n        src=\"/static/b9470291b92a78a5e117138f89fc6b14/c1b63/cs-multiprocessing_multithreading.png\"\n        srcset=\"/static/b9470291b92a78a5e117138f89fc6b14/5a46d/cs-multiprocessing_multithreading.png 300w,\n/static/b9470291b92a78a5e117138f89fc6b14/0a47e/cs-multiprocessing_multithreading.png 600w,\n/static/b9470291b92a78a5e117138f89fc6b14/c1b63/cs-multiprocessing_multithreading.png 1200w,\n/static/b9470291b92a78a5e117138f89fc6b14/2b608/cs-multiprocessing_multithreading.png 1540w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>from <a href=\"https://www.toptal.com/ruby/ruby-concurrency-and-parallelism-a-practical-primer\">https://www.toptal.com/ruby/ruby-concurrency-and-parallelism-a-practical-primer</a></p>\n<ul>\n<li>같은 작업을 실행할 때, 멀티프로세스에 비해 멀티스레드는 메모리 공간을 적게 차지한다.</li>\n<li>멀티프로세스는 좀비 프로세스의 가능성이 있는 반면, 멀티스레드는 프로세스가 종료되면 모든 스레드가 일괄적으로 종료된다.</li>\n<li>멀티스레드는 context switching에 드는 시간이 절약하고, overhead가 적다.</li>\n<li>멀티프로세스는 자원을 공유하지 않아 각각 독립적으로 실행되는 반면, 멀티스레드는 자원을 공유하므로 서로 통신할 수 있다.</li>\n<li>여러 장점에도 불구하고, 멀티스레드 환경에서 하나의 스레드에 생긴 문제가 프로세스 전체에 영향을 줄 수 있다. 따라서 멀티프로세스가 코딩과 디버깅은 더 간편하다.</li>\n</ul>\n<h4>[참고] IPC; Inter-Process Communication</h4>\n<p>프로세스 사이에는 기본적으로 자원을 공유하지 않지만, 자원을 공유하는 것이 가능하며 이를 IPC 라고 한다.</p>\n<ul>\n<li>예를 들어 한 프로세스가 파일을 쓰고 다음 프로세스가 쓰여진 파일을 읽는다면 파일을 통해 프로세스 간 통신이 이루어진 것으로 볼 수 있다.</li>\n<li>또 프로세스 간에 서로 공유하는 메모리 영역을 shared memory라고 한다.</li>\n<li>이외에도 소켓, 파이프 등을 통해 프로세스들이 통신할 수 있다.</li>\n</ul>\n<br>\n<h3>참고자료</h3>\n<ul>\n<li>『혼자 공부하는 컴퓨터 구조 + 운영체제』, 강민철, 한빛미디어</li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .abyss { background-color: #000c18; }\n  .abyss .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","frontmatter":{"title":"[OS] 프로세스와 스레드","date":"September 03, 2022"}}},"pageContext":{"slug":"/CS/OS/2022-09-03-cs-process-n-thread/","previous":{"fields":{"slug":"/CS/OS/2022-08-31-cs-os/"},"frontmatter":{"title":"[OS] 운영 체제"}},"next":{"fields":{"slug":"/CS/OS/2022-09-04-cs-cpu-scheduling/"},"frontmatter":{"title":"[OS] CPU 스케줄링"}}}},"staticQueryHashes":["1185972000","3231742164"],"slicesMap":{}}