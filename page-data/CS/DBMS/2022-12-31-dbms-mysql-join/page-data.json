{"componentChunkName":"component---src-templates-blog-post-js","path":"/CS/DBMS/2022-12-31-dbms-mysql-join/","result":{"data":{"allMarkdownRemark":{"totalCount":49},"markdownRemark":{"id":"10917a54-58aa-50ac-95e2-86445cbfa78a","html":"<p>원하는 정보가 여러 테이블에 흩어져 있는 경우, 몇 개의 외부 테이블을 합치는 명령어가 필요하다. Pandas 패키지에서 데이터프레임을 병합하는 경우를 생각해보자(사실 pandas 공식 문서에는 merge를 SQL의 JOIN을 들어 설명하고 있지만, 이미 pandas를 사용해본 경험이 있다면 이해가 빠를 것이다). <code>df1.merge(df2, how='inner', on='col1')</code>명령어는 df1에 df2를 양쪽 데이터프레임에 공통적으로 존재하는 col1의 값들이 일치되도록 병합한다. 반면 <code>df1.merge(df2, how='left', on='col1')</code>은 왼쪽, 즉 df1의 키만 보존하며 두 데이터프레임을 병합한다.</p>\n<p>이처럼 테이블을 합치는 방법은 여러가지가 있으며, 여기서는 <strong>INNER, OUTER, CROSS JOIN</strong>을 소개한다.</p>\n<br>\n<br>\n<h2>INNER JOIN</h2>\n<p>INNER JOIN을 위해서는 합치고자 하는 테이블에 공통된 키가 있어야 한다. 쿼리는 <code>JOIN {외부 테이블} ON {공통된 칼럼}</code> 형식이다. 공통된 키에 대해 병합되기 때문에 공통된 칼럼에 대한 두 테이블의 교집합을 떠올릴 수 있다(단, 엄밀히 테이블은 집합이 아니다!).</p>\n<pre class=\"grvsc-container abyss\" data-language=\"sql\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">SELECT</span><span class=\"mtk1\"> </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col1</span><span class=\"mtk1\">, </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span><span class=\"mtk1\">, </span><span class=\"mtk4\">B</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span><span class=\"mtk1\">, </span><span class=\"mtk4\">C</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">FROM</span><span class=\"mtk1\"> table1 A</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">JOIN</span><span class=\"mtk1\"> table2 B</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">ON</span><span class=\"mtk1\"> </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col1</span><span class=\"mtk1\"> </span><span class=\"mtk7\">=</span><span class=\"mtk1\"> </span><span class=\"mtk4\">B</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">JOIN</span><span class=\"mtk1\"> table3 C</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">ON</span><span class=\"mtk1\"> </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span><span class=\"mtk1\"> </span><span class=\"mtk7\">=</span><span class=\"mtk1\"> </span><span class=\"mtk4\">C</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col3</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">WHERE</span><span class=\"mtk1\"> condition1</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">ORDER BY</span><span class=\"mtk1\"> sort_standard1</span></span></span></code></pre>\n<ul>\n<li><code>FROM table1 A</code>는 table1을 A로 명명하고, <code>JOIN table2 B</code>는 table2를 B로 명명한다. 이후 어느 테이블에서 행을 가져오는지 명시할 때 새로 명시한 이름을 사용할 수 있다.</li>\n<li>위의 예에서 처럼 여러개의 테이블을 병합할 수 있다. 쿼리 형식 <code>JOIN {외부 테이블} ON {공통된 칼럼}</code>만 지키면 된다.</li>\n<li>또한, <code>WHERE</code>나 <code>ORDER BY</code>등 <code>SELECT</code>에서 익힌 조건문들도 그대로 사용할 수 있다는 걸 잊지 말자.</li>\n</ul>\n<p>그렇다면 하나의 테이블을 두번 JOIN할 일은 없을까? 의외로 하나의 테이블을 다시 외부 테이블처럼 JOIN하는 활용처도 있으며, 이를 SELF JOIN이라고 한다.</p>\n<pre class=\"grvsc-container abyss\" data-language=\"sql\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">SELECT</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col1</span><span class=\"mtk1\">, </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span><span class=\"mtk1\"> </span><span class=\"mtk7\">AS</span><span class=\"mtk1\"> val,</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">    </span><span class=\"mtk4\">B</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col1</span><span class=\"mtk1\">, </span><span class=\"mtk4\">B</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span><span class=\"mtk1\"> </span><span class=\"mtk7\">AS</span><span class=\"mtk1\"> next_val</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">FROM</span><span class=\"mtk1\"> table1 A </span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">JOIN</span><span class=\"mtk1\"> table2 B</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">  </span><span class=\"mtk7\">ON</span><span class=\"mtk1\"> </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span><span class=\"mtk1\"> </span><span class=\"mtk7\">+</span><span class=\"mtk1\"> </span><span class=\"mtk4\">1</span><span class=\"mtk1\"> </span><span class=\"mtk7\">=</span><span class=\"mtk1\"> </span><span class=\"mtk4\">B</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span></span></span></code></pre>\n<p>이처럼 하나의 칼럼에 lag를 두는 경우, 서로 다른 칼럼을 가져오는 것처럼 JOIN으로 불러와 활용할 수 있다.</p>\n<br>\n<br>\n<h2>OUTER JOIN</h2>\n<p>OUTER JOIN은 공통된 키가 아닌 하나의 테이블이 가지는 키를 기준으로 합치는 방법이며, 합치고자 하는 방향에 따라 LEFT JOIN과 RIGHT JOIN으로 나뉜다. 쿼리는 <code>LEFT JOIN {외부 테이블}</code>과 <code>RIGHT JOIN {외부 테이블}</code>이다.</p>\n<pre class=\"grvsc-container abyss\" data-language=\"sql\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">SELECT</span><span class=\"mtk1\"> </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col1</span><span class=\"mtk1\">, </span><span class=\"mtk4\">B</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col1</span><span class=\"mtk1\">, </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span><span class=\"mtk1\">, </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col3</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">FROM</span><span class=\"mtk1\"> table1 A</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">LEFT JOIN</span><span class=\"mtk1\"> table2 B</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk1\">       </span><span class=\"mtk7\">ON</span><span class=\"mtk1\"> </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span><span class=\"mtk1\"> </span><span class=\"mtk7\">=</span><span class=\"mtk1\"> </span><span class=\"mtk4\">B</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span><span class=\"mtk1\"> </span><span class=\"mtk7\">AND</span><span class=\"mtk1\"> </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col3</span><span class=\"mtk1\"> </span><span class=\"mtk7\">=</span><span class=\"mtk1\"> </span><span class=\"mtk4\">B</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col3</span></span></span></code></pre>\n<ul>\n<li><code>LEFT JOIN</code>을 <code>RIGHT JOIN</code>으로 바꿔 쓸 수 있다.</li>\n<li>LEFT JOIN은 table1(또는 A)의 키를 기준으로 합치며, RIGHT JOIN은 table2(또는 B)의 키를 기준으로 합친다. 기준이 되지 않는 테이블에 있는 칼럼 값이 NULL이더라도 기준이 되는 칼럼 값이 존재하면 반환하므로, 결과값으로 반환되는 테이블의 행의 갯수는 기준이 되는 칼럼의 합치기 전 행의 갯수와 같다.</li>\n</ul>\n<br>\n<h3>CROSS JOIN</h3>\n<p>두 칼럼 값의 모든 조합 쌍을 나타내는 카르테지안 프로덕트(Cartesian Product)를 실행하는 방법도 있다. <code>CROSS JOIN {외부 테이블}</code> 명령으로 구현하며, 이를 CROSS JOIN이라고 한다.</p>\n<pre class=\"grvsc-container abyss\" data-language=\"sql\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">SELECT</span><span class=\"mtk1\"> </span><span class=\"mtk4\">A</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col1</span><span class=\"mtk1\">, </span><span class=\"mtk4\">B</span><span class=\"mtk1\">.</span><span class=\"mtk4\">col2</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">FROM</span><span class=\"mtk1\"> table1 A</span></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"><span class=\"mtk7\">CROSS</span><span class=\"mtk1\"> </span><span class=\"mtk7\">JOIN</span><span class=\"mtk1\"> table2 B</span></span></span></code></pre>\n<p>결과값은 <code>A.col1</code>와 <code>B.col2</code>의 모든 조합 썅을 담은 테이블이다.</p>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .abyss { background-color: #000c18; }\n  .abyss .mtk7 { color: #225588; }\n  .abyss .mtk1 { color: #6688CC; }\n  .abyss .mtk4 { color: #F280D0; }\n  .abyss .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n  }\n</style>","frontmatter":{"title":"[MySQL] JOIN","date":"December 31, 2022"}}},"pageContext":{"slug":"/CS/DBMS/2022-12-31-dbms-mysql-join/","previous":{"fields":{"slug":"/CS/DBMS/2022-12-31-dbms-mysql-functions/"},"frontmatter":{"title":"[MySQL] 함수와 집계함수"}},"next":{"fields":{"slug":"/AI/Vision/vivit-tokenizing/"},"frontmatter":{"title":"[실험] ViViT의 토큰화 방법 비교하기"}}}},"staticQueryHashes":["1185972000","3231742164"],"slicesMap":{}}